/* eslint-disable camelcase */
'use strict';
var request = require('request');
var tokenUtils = require('./token-utils');
var uuid = require('uuid/v4');
var dynamicRoutingUtils = require('./dynamic-routing-utils');

module.exports.logRequestError = function(req, message) {
  if (req && req.logger && process.env.SAAS_APPROUTER) {
    req.logger.error(message);
  }
};

module.exports.logRequestSetTenant = function(req, tenant) {
  if (req && req.logger) {
    req.logger.setTenantId(tenant);
    if (!req.logger.getCorrelationId()) {
      req.logger.setCorrelationId(req.headers['x-correlationid'] || req.headers['x-request-id'] ||
          req.headers['x-vcap-request-id'] || uuid());
    }
  }
};

module.exports.getApplicationLogs = function(req, res) {
  return new Promise((resolve, reject) => {
    tokenUtils.getAuthenticationJar(function(err, jar) {
      if (err) {
        return reject(err);
      }
      const query = kibanaQuery(req);
      const requestOptions = {
        url: process.env.LOGS_URL + '/elasticsearch/_msearch',
        jar: jar,
        headers: {
          'kbn-xsrf': 'true',
          'Content-Type': 'application/x-ndjson'
        },
        body: query
      };
      module.exports.callKibanaServer(requestOptions, query, function(err, respBody) {
        if (err) {
          return reject(err);
        }
        const logs = [];
        respBody.responses.forEach((response) => {
          response.hits.hits.forEach((hit) => {
            if (hit._source.msg) {
              logs.push({
                message: hit._source.msg,
                correlationId: hit._source.correlation_id,
                timestamp: hit._source['@timestamp'],
                level: hit._source.level
              });
            }
          });
        });
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(logs));
      });
    });
  });
};

module.exports.callKibanaServer = function(requestOptions, query, cb) {
  request.post(requestOptions, function(err, response, body) {
    if (err || response.statusCode !== 200) {
      const error = new Error('Failed to execute query ' + query + ' response status ' +
          response.statusCode + ' ' + (body ? body : '') + err);
      return cb(error);
    }
    const respBody = JSON.parse(response.body);
    cb(null, respBody);
  });
};

function kibanaQuery(req) {
  const timeRange = 1440; // One day in minutes
  const timestampNow = new Date();
  const end = timestampNow.getTime();
  const start = end - timeRange * 60 * 1000;
  const timestampYesterday = new Date(timestampNow);
  timestampYesterday.setHours(timestampYesterday.getHours() - 24);
  if (req.headers['x-application-key']){
    let applicationKey = dynamicRoutingUtils.getApplicationKey({url: '/' + req.headers['x-application-key']});
    let tenantKey = applicationKey && applicationKey.appDestinationId ? req.tenant + '-' + applicationKey.appDestinationId + '.' + applicationKey.appPrefix + '.' + applicationKey.appNameWithoutPrefix :
      req.tenant + '-' + applicationKey.appPrefix + '.' + applicationKey.appNameWithoutPrefix;
    return kibanaDayQuery(timestampNow, start, end, tenantKey);
  } else {
    return kibanaDayQuery(timestampNow, start, end, req.tenant);
  }
}

function kibanaDayQuery(timestampReferenceDay, startTime, endTime, tenant) {
  const todayString = timestampReferenceDay.toISOString().substring(0, 10);
  const kibanaQuery0 = {
    'index': ['logstash-2016.07.01-es5'],
    'ignore_unavailable': true
  };
  kibanaQuery0.index = 'logstash-' + todayString.replace(/-/g, '.');

  const kibanaQuery1 = { // AppELK template
    'size': 10000,
    '_source': ['msg', '@timestamp', 'level', 'correlation_id'],
    'query': {
      'bool': {
        'must': [{
          'range': {
            '@timestamp': {
              'format': 'epoch_millis',
              'gte': startTime,
              'lte': endTime
            }
          }
        }, {
          'match': {
            'tenant_id': tenant
          }
        }, {
          'match': {
            'level': 'ERROR'
          }
        }]
      }
    }
  };
  return JSON.stringify(kibanaQuery0) + '\n' + JSON.stringify(kibanaQuery1) + '\n';
}
