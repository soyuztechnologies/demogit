'use strict';

var loggingUtils = require('./logger');
var logger = loggingUtils.getLogger('/Subscription');
var urlUtils = require('../utils/url-utils');
var vcapUtils = require('../utils/vcap-utils');
var configUtils = require('../utils/configuration-utils');
var xsenv = require('@sap/xsenv');
var xssec = require('@sap/xssec');
var uaaUtils = require('./uaa-utils');
var iasUtils = require('./ias-utils');
var urijs = require('urijs');
var pki = require('node-forge').pki;

exports.getSaaSRegistryDependencies = getSaaSRegistryDependencies;
exports.getSMSDependencies = getSMSDependencies;
exports.checkScopes = checkScopes;
exports.checkCertificate = checkCertificate;
exports.getSaaSRegistryApplicationUrl = getSaaSRegistryApplicationUrl;
exports.getSMSApplicationUrl = getSMSApplicationUrl;
exports.getError = getError;
exports.getSaaSRegistryCallbackPath = getSaaSRegistryCallbackPath;
exports.getSMSCallbackPath = getSMSCallbackPath;

function checkScopes(req, cb){
  try {
    var token = getToken(req);
    var ownUAACredentials = xsenv.serviceCredentials({label: 'xsuaa'});
    xssec.createSecurityContext(token, ownUAACredentials, function (err, ctx) {
      if (err) {
        cb(err, null);
      } else if (!findCallbackScope(ctx)) {
        logger.error('Missing the expected scope - Callback - in the call to create subscription');
        var error = getError('Forbidden - Missing the expected scope', 403);
        cb(error, null);
      } else {
        cb(null, true);
      }
    });
  } catch (error) {
    cb (error);
  }
}

function checkCertificate(req,credentials, cb){
  let message;
  let clientCertificate = req.headers[process.env.CLIENT_CERTIFICATE_HEADER_NAME || 'x-forwarded-client-cert'];
  if (!clientCertificate){
    message = 'Missing certificate for subscription manager callback in SMS subscription';
    logger.error(message);
    let error = getError(message, 401);
    return cb(error);
  }

  if (!credentials.callback_certificate_subject){
    message = 'Missing certificate subject for subscription manager callback in the call to create subscription';
    logger.error(message);
    let error = getError(message, 401);
    return cb(error);
  }

  let subj;
  try {
    subj = typeof credentials.callback_certificate_subject === 'string' ?
      JSON.parse(credentials.callback_certificate_subject) : credentials.callback_certificate_subject;
  } catch (err){
    message = 'failed to parse certificate subject in SMS subscription';
    logger.error(message);
    return cb(getError(message + ' ' + err, 500));
  }

  const certStr = '-----BEGIN CERTIFICATE-----\n' + clientCertificate + '\n-----END CERTIFICATE-----';
  var crt;
  try {
    crt = pki.certificateFromPem(certStr);
  } catch (err){
    message = 'Failed to parse certificate';
    logger.error(message);
    return cb(getError(message + ' ' + err, 500));
  }

  var certCN = crt.subject.getField('CN').value;
  var certL = crt.subject.getField('L').value;
  var certOUN = crt.subject.attributes.filter((item) => item.shortName === 'OU').map((item) => { return item.value; });
  var certON = crt.subject.getField('O').value;
  var certC = crt.subject.getField('C').value;

  if (certCN !== subj.CN) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid common name ' + certCN;
    logger.error(message);
    return cb(getError(message, 403));
  }
  if (certL !== subj.L) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid locality name ' + certL ;
    logger.error(message);
    return cb(getError(message, 403));
  }
  if (certON !== subj.O) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid organization name ' + certON;
    logger.error(message);
    return cb(getError(message, 403));
  }
  if (certC !== subj.C) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid country name ' + certC ;
    logger.error(message);
    return cb(getError(message, 403));
  }

  var oun1 = certOUN.sort();
  var oun2 = subj.OU;

  if (!Array.isArray(oun1) &&
    Array.isArray(oun2) &&
    oun1.length === oun2.length &&
    oun1.every((val, index) => val === oun2[index])){
    message = 'Error - failed to validate certificate in SMS subscription, invalid organization unit names ' + certOUN ;
    logger.error(message);
    return cb(getError(message, 403));
  }
  cb();
}

function findCallbackScope(ctx){
  if (process.env.SAAS_APPROUTER){
    return true;
  } else {
    return ctx.checkLocalScope('Callback');
  }
}

function getToken (req){
  var authorization = req.headers.authorization;
  if (!authorization) {
    logger.error('Missing Authorization header');
    throw getError('Missing Authorization header', 401);
  }
  var parts = authorization.split(' ');
  if (parts.length < 2) {
    logger.error('Invalid Authorization header format');
    throw getError('Invalid Authorization header format', 400);
  }
  var scheme = parts[0];
  var token = parts[1];

  if (scheme.toLowerCase() !== 'bearer') {
    logger.error('Authorization header is not a Bearer token');
    throw getError('Authorization header is not a Bearer token', 401);
  }
  return token;
}

function getSMSApplicationUrl(req,smsCredentials, cb){
  if (!req.body){
    let error = getError('Bad request: Missing body', 400);
    return cb(error);
  }
  const iasTenantHost = req.body.subscriber && req.body.subscriber.tenantHost;
  let subscriberIasTenant = iasTenantHost.substring(0, iasTenantHost.indexOf('.'));
  let subscriberTenant = req.body.subscriber.zoneId + '--' + subscriberIasTenant;

  iasUtils.getIasConfig(req, function (err, iasOptions) {
    if (err) {
      return cb(err);
    }
    if (!iasOptions) {
      return cb('Invalid ias options');
    }
    let approuterHost = urlUtils.getRedirectHost(req).replace('.cert.','.');
    let providerTenant = getTenant(approuterHost);
    approuterHost =  approuterHost.replace(providerTenant, subscriberTenant);
    let proto = req.headers['x-forwarded-proto'] || req.protocol;
    const response = {
      applicationURL: proto + '://' + approuterHost
    };
    cb(null, response);
  });
}

function getSaaSRegistryApplicationUrl(req,cb){
  var error = null;
  if (!req.body){
    error = getError('Bad request: Missing body', 400);
    return cb(error);
  }

  var subdomain = req.body.subscribedSubdomain;
  if (!subdomain) {
    error = getError('Bad request: Missing subscribedSubdomain', 400);
    return cb(error);
  }

  uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
    if (err) {
      return cb(err);
    }
    if (!uaaOptions) {
      return cb('Invalid UAA options');
    }

    if (uaaOptions.tenantmode !== 'shared'){
      error = getError('Tenant mode should be shared', 500);
      return cb(error);
    }
    var proto = req.headers['x-forwarded-proto'] || req.protocol;
    var url = proto + '://' + urlUtils.getRedirectHost(req).replace(uaaOptions.tenant, subdomain);
    return cb(null, url);
  });
}

function getError(errorStr, status){
  var error = new Error(errorStr);
  error.status = status;
  logger.error(errorStr);
  return error;
}
function getSMSDependencies(){
  return exports.getSaaSRegistryDependencies();
}

function getSaaSRegistryDependencies(){
  var dependenciesArray = [];
  var appId = null;
  var appName = null;
  var xsappname = null;
  var services = xsenv.readServices();
  for (var service in services) {
    xsappname = appId = appName = null;
    var svcName = services[service].label;

    var cred = services[service].credentials;
    if (svcName === 'destination' || svcName === 'connectivity'){
      appId = cred.xsappname;
      appName = svcName;
    } else if (cred.saasregistryappname){
      appId = cred.uaa.xsappname;
      appName = cred.saasregistryappname;
    } else if (cred.saasregistryenabled){
      xsappname = cred.uaa.xsappname;
    }
    var obj = null;
    if (appId && appName) {
      obj = {'appId': appId, 'appName': appName};
    } else if (xsappname){
      obj = {'xsappname': xsappname};
    }
    if (obj){
      dependenciesArray.push(obj);
    }
  }
  return dependenciesArray;
}

function getSaaSRegistryCallbackPath(credentials){
  var callBackPath = {
    getDependenciesPath: '/callback/v1.0/dependencies',
    onSubscriptionPrefix: '/callback/v1.0/tenants'
  };
  if (!credentials){
    credentials = vcapUtils.getServiceCredentials({ label: 'saas-registry' });
  }
  if (!credentials){
    return callBackPath;
  }
  try {
    if (credentials.appUrls) {
      var appUrlsJson = JSON.parse(credentials.appUrls);
      var parsedUrl = urijs.parse(appUrlsJson.getDependencies);
      callBackPath.getDependenciesPath = parsedUrl.path;
      parsedUrl = urijs.parse(appUrlsJson.onSubscription);
      let index = parsedUrl.path.indexOf('/{tenantId}');
      if (index > 0){
        parsedUrl.path = parsedUrl.path.substring(0,index);
      }
      callBackPath.onSubscriptionPrefix = parsedUrl.path;
    }
  } catch (e){
    return callBackPath;
  }
  return callBackPath;
}

function getSMSCallbackPath(credentials){
  var callBackPath = {
    getDependenciesPrefix: '/v1.0/callback/zones',
    onSubscriptionPrefix: '/v1.0/callback/zones'
  };
  if (!credentials){
    credentials = vcapUtils.getServiceCredentials({ label: 'subscription-manager' });
  }
  if (!credentials){
    return callBackPath;
  }
  try {
    var appUrlsJson = typeof credentials.app_urls === 'string' ? JSON.parse(credentials.app_urls) : credentials.app_urls;
    var parsedUrl = urijs.parse(appUrlsJson.dependenciesCallbacks.url);
    let index = parsedUrl.path.indexOf('/{zoneId}');
    if (index > 0){
      parsedUrl.path = parsedUrl.path.substring(0,index);
    }
    callBackPath.getDependenciesPrefix = parsedUrl.path;
    parsedUrl = urijs.parse(appUrlsJson.subscriptionCallbacks.url);
    index = parsedUrl.path.indexOf('/{zoneId}');
    if (index > 0){
      parsedUrl.path = parsedUrl.path.substring(0,index);
    }
    callBackPath.onSubscriptionPrefix = parsedUrl.path;
  } catch (e){
    logger.error('Failed to parse sms app_urls' + e);
    throw getError('Failed to parse sms app_urls', 500);
  }
  return callBackPath;
}

function getTenant(approuterHost){
  let tenant = null;
  if (process.env.TENANT_HOST_PATTERN){
    let tenantHostPattern = configUtils.constructRegExp(process.env.TENANT_HOST_PATTERN);
    tenant = uaaUtils.retrieveTenantFromURL(approuterHost, tenantHostPattern);
  }
  return tenant;
}