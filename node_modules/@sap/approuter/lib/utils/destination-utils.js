'use strict';

const _ = require('lodash');
const loggingUtils = require('./logger');
const logger = loggingUtils.getLogger('/Destination service');
const xsenv = require('@sap/xsenv');
const request = require('request');
const tokenUtils = require('./token-utils');
const validator = require('validator');

exports.adjustDestinationProperties = adjustDestinationProperties;
exports.normalizeDestinationProperties = normalizeDestinationProperties;
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
exports.findDestination = findDestination;
exports.getDestinationsByTenant = getDestinationsByTenant;
exports.getDestinationsByDestinationKey = getDestinationsByDestinationKey;
exports.getServiceInstanceDestinationsByTenant = getServiceInstanceDestinationsByTenant;

function getServiceInstanceDestinationsByTenant(req, cb) {
  const getDestinationPromises = [];
  let serviceInstanceDestinations = [];
  const tenant = req.tenant;
  getDestinationInstanceCredentialsByTenant(req, function(err, tenantDestinations) {
    if (err) {
      return cb(err);
    }
    if (!tenantDestinations || tenantDestinations.length === 0) {
      return cb(null, serviceInstanceDestinations);
    }
    tenantDestinations.forEach((tenantDestination) => {
      getDestinationPromises.push(
        new Promise((resolve, reject) => {
          const destinationKey = tenant + '_' + tenantDestination.Name;
          getDestinationsByDestinationKey(req.app, destinationKey,false, function(err, destinations) {
            if (err) {
              reject(err);
            } else {
              resolve(destinations);
            }
          });
        })
      );
    });
    Promise.all(getDestinationPromises)
      .then((values) => {
        values.forEach(function(instanceDestinations) {
          if (instanceDestinations) {
            serviceInstanceDestinations = serviceInstanceDestinations.concat(instanceDestinations);
          }
        });
        cb(null, serviceInstanceDestinations);
      }).catch((reason) => {
        cb(reason);
      });
  });
}

function getDestinationInstanceCredentialsByTenant(req, cb) {
  const token = req.app && req.app.services['destination'] && req.app.services['destination'].token;
  const tenantDestinations = [];
  getDestinationsByTenant(null, token,req.zoneInfo, function(err, destinations) {
    if (err) {
      return cb(err);
    }
    destinations.forEach((destination) => {
      if (validator.isUUID(destination.Name, 4) && destination.tokenServiceURL &&
          req.tenant.toLowerCase() === destination.tokenServiceURL.substring(8, destination.tokenServiceURL.indexOf('.'))) {
        tenantDestinations.push(destination);
      }
    });
    cb(null, tenantDestinations);
  });
}

function getDestinationsByDestinationKey(app, destinationKey,runtimeFlow, cb) {
  let destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
  if (!destinationToken || destinationToken.tokenRefreshTimestamp - Date.now() <= 0 || !app.services[destinationKey].credentials) {
    // eslint-disable-next-line no-unused-vars
    const [tenant, destinationId] = destinationKey.split('_');
    findDestination(destinationId, null, {app: app}, function(err, response) {
      if (err || !response || !response.destinationConfiguration) {
        return cb('Failed to get subaccount destination by destination key for destination key ' + destinationKey + ' ' + err);
      }
      const credentials = {
        url: response.destinationConfiguration.tokenServiceURL,
        clientid: response.destinationConfiguration.clientId,
        clientsecret: response.destinationConfiguration.clientSecret
      };
      tokenUtils.loadClientCredentialsToken(app, credentials, destinationKey, function(err) {
        if (err) {
          let [subdomain, destinationId] = destinationKey.split('_');
          let message = 'Error while fetching client_credentials token for destination service instance '
              + destinationId + ' from subdomain ' + subdomain + ' ' + err;
          if (runtimeFlow){
            return cb(message);
          } else { // get applications flow
            logger.error(message);
            return cb();
          }
        }
        destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
        app.services[destinationKey].credentials = response.destinationConfiguration;
        return getDestinationsByServiceInstance(destinationToken, destinationKey, cb);
      });
    });
  } else {
    return getDestinationsByServiceInstance(destinationToken, destinationKey, cb);
  }
}

function getDestinationsByServiceInstance(token, destinationKey, cb) {
  getDestinationsByInstanceReqOptions(token, function(err, requestOptions) {
    if (err) {
      return cb('Error while retrieving destinations for service instance ' + destinationKey + err);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err) {
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destinations for service instance ' + destinationKey + err);
      }
      if (res.statusCode !== 200 || !res.body) {
        const errorMessage = 'Error while retrieving destinations for service instance ' + destinationKey + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        const destinationLookUpResult = JSON.parse(res.body);
        destinationLookUpResult.forEach((destination) => {
          destination.destinationId = destinationKey.split('_')[1];
        });
        return cb(null, destinationLookUpResult);
      } catch (err) {
        return cb(err);
      }
    });
  });
}

function getDestinationsByInstanceReqOptions(token, cb) {
  const credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb ('Destination service is not bound');
  }
  const headers = {'accept': 'application/json;charset=utf-8'};
  headers.Authorization = 'Bearer ' + token.accessToken;
  return cb (null, {
    url: credentials.uri + '/destination-configuration/v1/instanceDestinations',
    headers: headers
  });
}

function getDestinationsByTenant(tenant, token,zoneInfo, cb) {
  getDestinationsByTenantReqOptions(tenant, token,zoneInfo, function(error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err) {
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destinations for tenant ' + tenant);
      }
      if (res.statusCode !== 200 || !res.body) {
        var errorMessage = 'Error while retrieving destinations for tenant ' + tenant + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function adjustDestinationProperties(destinations) {
  destinations.forEach(function(destination) {
    if (destination.proxyType === 'OnPremise') {
      try {
        var credentials = xsenv.serviceCredentials({tag: 'connectivity'});
        destination['proxyHost'] = credentials.onpremise_proxy_host;
        destination['proxyPort'] = credentials.onpremise_proxy_port;
      } catch (error) {
        // eslint-disable-next-line no-useless-escape
        throw 'Destination \"' + destination.name +
        // eslint-disable-next-line no-useless-escape
        '\" with  ProxyType \"OnPremise\" but connectivity service is not bound.';
      }
    }
    _.defaults(destination, {
      timeout: 30000
    });
  });
}

function normalizeDestinationProperties(destinations) {
  if (!destinations) {
    return;
  }
  if (!Array.isArray(destinations)) {
    throw new Error('destinations type invalid, array is expected');
  }
  destinations.forEach(function(destination, i, destinations) {
    if (destinations[i].Authentication) { // if it destination from destinations service
      destinations[i] = normalizeDestination (destination);
      destinations[i].forwardAuthToken = destinations[i].forwardAuthToken === 'true' || destinations[i].forwardAuthToken === true;
      destinations[i].preserveHostHeader = destinations[i].preserveHostHeader === 'true' || destinations[i].preserveHostHeader === true;
      destinations[i].dynamicDestination = destinations[i].dynamicDestination === 'true' || destinations[i].dynamicDestination === true;
      if (destinations[i].hasOwnProperty('setXForwardedHeaders')) {
        destinations[i].setXForwardedHeaders = destinations[i].setXForwardedHeaders === 'true' || destinations[i].setXForwardedHeaders === true;
      }
      if (destinations[i].timeout && !isNaN(destinations[i].timeout)) {
        destinations[i].timeout = _.toSafeInteger(destinations[i].timeout);
      }
    }
  });
}

function getDestinationsByTenantReqOptions(tenant,token,zoneInfo,cb) {
  var credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb ('Destination service is not bound');
  }
  var destinationUrl = credentials.uri + '/destination-configuration/v1/subaccountDestinations';

  var headers = {'accept': 'application/json;charset=utf-8'};
  if (token) {
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb (null, {
      url: destinationUrl,
      headers: headers
    });
  }
  tokenUtils.getClientCredentialsTokenByTenant(tenant, credentials,zoneInfo, function(err, token) {
    if (err) {
      return cb(err);
    }
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb (null, {
      url: destinationUrl,
      headers: headers
    });
  });
}

function getFindDestinationReqOptions(destinationName, token, options, cb) {
  let credentials = getDestinationServiceCredentials ();
  let headers = {'accept': 'application/json;charset=utf-8'};
  let userToken = null;
  if (token){
    userToken = token && token.token ? token : token;
  }
  if (!credentials) {
    return cb ('Destination service is not bound');
  }

  let auth;
  if (userToken && !options.preferLocal) {
    auth = userToken;
  } else if (options && options.destinationKey && options.app.services && options.app.services[options.destinationKey]) {
    auth = options.app.services[options.destinationKey].token.accessToken;
  } else if (options && options.app && options.app.services['destination'] && options.app.services['destination'].token) {
    auth = options.app.services['destination'].token.accessToken;
  } else {
    return cb('Failed to determine destination token');
  }
  headers.Authorization = 'Bearer ' + auth;
  if (options.preferLocal && userToken) {
    headers['x-user-token'] = userToken;
  }
  return cb (null, {
    url: credentials.uri + '/destination-configuration/v1/destinations/' + destinationName,
    headers: headers
  });
}

function normalizeDestination(destination) {
  if (!destination) {
    return;
  }
  var keys = Object.keys(destination);
  var n = keys.length;
  var newobj = {};
  var key;
  while (n--) {
    key = keys[n];
    if (key === 'URL') {
      newobj[key.toLowerCase()] = destination[key];
    } else {
      var value = destination[key];
      key = key.replace('HTML5.', '');
      var newKey = key.substr(0, 1).toLowerCase() + key.substr(1);
      newobj[newKey] = value;
    }
  }
  return newobj;
}

function getDestinationServiceCredentials() {
  var errorOccurred;
  var credentials;
  try {
    credentials = xsenv.serviceCredentials({tag: 'destination'});
  } catch (e) {
    errorOccurred = true;
  }
  if (errorOccurred || !credentials) {
    return null;
  }
  return credentials;
}

// Finds a destination by name on all levels and returns the first match
// Search priority is destination on instance level and after that fallback to the shared destinations on subaccount level.
function findDestination(destinationName, token, options, cb) {
  if (!destinationName) {
    return cb('Cannot find destination, destination name is missing');
  }

  if (destinationName.includes('$')) {
    return cb('destination contains invalid characters, check xs-app.json route.source attribute to make sure the regex is correct');
  }

  if (destinationName.includes('*')) {
    return cb('destination contains invalid characters, make sure the DESTINATION_HOST_PATTERN regex is correct');
  }

  var errorMessage;
  getFindDestinationReqOptions(destinationName, token, options, function(error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err) {
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destination ' + destinationName + ' from destination service');
      }
      if (res.statusCode !== 200 || !res.body) {
        errorMessage = 'Error while retrieving destination ' + destinationName + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}
