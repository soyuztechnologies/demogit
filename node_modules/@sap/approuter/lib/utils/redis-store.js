'use strict';

const zlib = require('zlib');
const Redis = require('ioredis');
const tracer = require('../utils/logger').getTracer(__filename);
const vcapUtils = require('../utils/vcap-utils');
Redis.Promise = require('bluebird');

const REDIS_SCALE_READS = process.env.REDIS_SCALE_READS || 'all';

const initClusterModeClient = (client, credentials) => {
  const redisOptions = {
    tls: {},
    password: credentials.password
  };

  addRetryStrategy(client, redisOptions);

  client = new Redis.Cluster([ {
    port: credentials.port || credentials.tls.port,
    host: credentials.hostname || credentials.tls.host || credentials.tls.hostname
  } ], {
    dnsLookup: (address, callback) => callback(null, address),
    scaleReads: REDIS_SCALE_READS,
    redisOptions
  });

  return client;
};

const initRegularClient = (client, credentials) => {
  const redisOptions = {};
  if (credentials.ca_base64) {
    redisOptions.tls = { ca: Buffer.from(credentials.ca_base64, 'base64').toString('utf-8') };
  } else if (credentials.tls) {
    redisOptions.tls = {
      host: credentials.hostname || credentials.tls.host || credentials.tls.hostname,
      port: credentials.port || credentials.tls.port
    };
    redisOptions.password = credentials.password;
  } else {
    redisOptions.host = credentials.hostname;
    redisOptions.port = credentials.port;
    redisOptions.password = credentials.password;
  }
  addRetryStrategy(client, redisOptions);

  client = new Redis(redisOptions);

  return client;
};

const addRetryStrategy = (client, redisOptions) => {
  redisOptions.retryStrategy = (times) => {
    tracer.debug(`addRetryStrategy - retryStrategy times ${ times }`);
    let timeout;
    if (times < 3) {
      timeout = Math.min(times * 50, 2000);
    } else {
      client = null;
    }
    return timeout;
  };
  if (process.env.DEV_ENV_TRACES === 'true') {
    redisOptions.showFriendlyErrorStack = true;
  }
  redisOptions.maxRetriesPerRequest = 2;
};

const initClient = (name) => {
  let client = null;
  try {
    const credentials = vcapUtils.getServiceCredentials({ name });
    if (credentials.cluster_mode === true) {
      client = initClusterModeClient(client, credentials);
    } else {
      client = initRegularClient(client, credentials);
    }
  } catch (err) {
    tracer.error(err);
    return null;
  }

  client.on('error', (err) => {
    tracer.error(`initClient - Redis connection error, err.code ${ err.code }, err: ${ JSON.stringify(err) }`);
    if (err && err.code === 'ECONNREFUSED') {
      tracer.error('initClient - onError - The server refused the connection');
    }
  });

  return client;
};

const PREFIX = '{approuter-sessions}';

const redisKey = (key) => `${ PREFIX }:${ key }`;

const compress = (data) => {
  const zip = zlib.gzipSync(Buffer.from(JSON.stringify(data)), { level: zlib.constants.Z_BEST_SPEED });
  const buff = new Buffer(zip);
  return buff.toString('base64');
};

const decompress = (base64data) => {
  if (!base64data) {
    return null;
  }
  const buff = new Buffer(base64data, 'base64');
  let zipBuff = Buffer.from(buff);
  const jsons = zlib.gunzipSync(zipBuff).toString();
  return JSON.parse(jsons);
};

const log = {
  error(msg, ...args) {
    if (tracer.isEnabled('Error')) {
      tracer.error(msg, ...args);
    }
  },
  debug(msg, ...args) {
    if (tracer.isEnabled('debug')) {
      tracer.debug(msg, ...args);
    }
  }
};

class RedisStore {
  constructor(instanceName) {
    this.client = initClient(instanceName);
  }

  checkClient() {
    if (this.client) {
      return true;
    } else if (this.client === null || this.client.closing) {
      this.client = initClient();
      return this.client;
    }
  }

  async all() {
    if (this.checkClient()) {
      try {
        const keys = await this.client.keys(redisKey('*'));
        log.debug(`Got keys from redis: ${ JSON.stringify(keys) }`);
        return await this.client.mget(keys);
      } catch (err) {
        log.error(`Failed to get all sessions: ${ err.message }`);
        return [];
      }
    } else {
      tracer.warning('No redis client!!');
      return [];
    }
  }

  async clear() {
    if (this.checkClient()) {
      try {
        const keys = await this.client.keys(redisKey('*'));
        log.debug(`Got keys from redis: ${ JSON.stringify(keys) }`);
        await this.client.del(keys);
      } catch (err) {
        log.error(`Failed to clear all sessions: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async destroy(sessionId) {
    if (this.checkClient()) {
      try {
        log.debug(`Destroying session with id ${ sessionId }`);
        await this.client.del(redisKey(sessionId));
      } catch (err) {
        log.error(`Failed destroying session with id ${ sessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async get(sessionId) {
    if (this.checkClient()) {
      log.debug(`Getting session with id ${ sessionId }`);
      try {
        const session = await this.client.get(redisKey(sessionId));
        return decompress(session);
      } catch (err) {
        log.error(`Failed to get session with id ${ sessionId }: ${ err.message }`);
        return null;
      }
    } else {
      tracer.warning('No redis client!!');
      return null;
    }
  }

  async length() {
    if (this.checkClient()) {
      try {
        const keys = await this.client.keys(redisKey('*'));
        log.debug(`Keys length: ${ keys.length }`);
        return keys.length;
      } catch (err) {
        log.error(`Failed to get keys length: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
      return 0;
    }
  }

  async ttl(sessionId) {
    if (this.checkClient()) {
      try {
        log.debug(`Getting session ttl with id ${ sessionId }`);
        return await this.client.ttl(redisKey(sessionId));
      } catch (err) {
        log.error(`Failed to get ttl for session with id ${ sessionId }`);
        return 0;
      }
    } else {
      tracer.warning('No redis client!!');
      return 0;
    }
  }

  async set(sessionId, session, timeout) {
    if (this.checkClient()) {
      try {
        log.debug(`Storing session with id ${ sessionId }`);
        await this.client.set(redisKey(sessionId), compress(session), 'PX', timeout * 60 * 1000);
      } catch (err) {
        log.error(`Failed to set a session with id ${ sessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async exists(sessionId) {
    if (this.checkClient()) {
      try {
        log.debug(`Checking existence of session with id ${ sessionId }`);
        const exists = await this.client.exists(redisKey(sessionId));
        log.debug(`Session with id ${ sessionId } exists ? ${ !!exists }`);
        return !!exists;
      } catch (err) {
        log.error(`Failed to check if session ${ sessionId } exists: ${ err.message }`);
        return false;
      }
    } else {
      tracer.warning('No redis client!!');
      return false;
    }
  }

  async resetTimer(sessionId, timeout) {
    if (this.checkClient()) {
      try {
        log.debug(`Resetting time of session with id ${ sessionId } to ${ timeout } minutes`);
        await this.client.expire(redisKey(sessionId), timeout * 60 * 1000);
      } catch (err) {
        log.error(`Failed to expire session with id ${ sessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }
}

let store = null;

module.exports.getStore = (instanceName) => {
  if (!store) {
    store = new RedisStore(instanceName);
  }
  return store;
};
