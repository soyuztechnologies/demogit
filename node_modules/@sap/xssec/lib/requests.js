'use strict';

const constants = require('./constants');
const request = require('request');
const requestRetry = require('requestretry');
const url = require('url');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
const debug = require('debug');
const debugTrace = debug('xssec:requests');
const debugError = debug('xssec:requests');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

const X_ZONE_ID_HEADER_NAME = "x-zid";

function _requestToXSUAA(fnc, options, retryOptions, cb) {
    debugTrace(fnc + '::HTTP Call with %O', options);
    request.post(
        options,
        function (error, response, body) {
            if (error) {
                if (error.code === 'ETIMEDOUT' && error.connect === true) {
                    debugError( fnc + ': HTTP connection timeout.');
                }
                debugError(error.message);
                debugError(error.stack);
                return cb(error, null);
            }
            if (response.statusCode !== 200) {
                return cb(new Error(response.statusCode + " - " + body));
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e, null);
            }
            return cb(null, json.access_token, json)
        }
    );
};


function validateParameters(serviceCredentials, cb) {
    // input validation
    if (!serviceCredentials) {
        return new Error('Parameter serviceCredentials is missing but mandatory.');        
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        return new Error('Invalid service credentials: Missing clientid/clientsecret.');
    }
    if (!serviceCredentials.url) {
        return new Error('Invalid service credentials: Missing url.');
    }
    if(!cb || typeof cb !== 'function') {
        return new Error('No callback function provided.');
    }
}


function buildSubdomain(serviceCredentials, subdomain) {
    var urlWithCorrectSubdomain = serviceCredentials.url;
    if (subdomain) {
        var tokenSubdomain = subdomain;
        var tokenRequestSubdomain = null;
        var uaaUrl = url.parse(serviceCredentials.url);
        if (uaaUrl.hostname.indexOf('.') === -1) {
            tokenRequestSubdomain = null;
        } else {
            tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
        }
        if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
            urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
        }
    }

    return urlWithCorrectSubdomain;
}

function appendAdditonalAttribites(options, additionalAttributes) {
    if (additionalAttributes !== null) {
        var authorities = { "az_attr" : additionalAttributes };
        options.form.authorities = authorities;
    }
}

function DefaultHeaders(zoneId) {
    var ret = {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': constants.USER_AGENT
    };

    if(zoneId) {
        ret[X_ZONE_ID_HEADER_NAME] = zoneId;
    }

    return ret;
}

function buildOptions(serviceCredentials, additionalAttributes, url, grantType, zoneId, timeout) {
    // jwt bearer flow
    var options = {
        url: url + '/oauth/token',
        headers: DefaultHeaders(zoneId),
        form: {
            grant_type: grantType,
            response_type: 'token',
            client_id: serviceCredentials.clientid,
            client_secret: serviceCredentials.clientsecret            
        },
        timeout: timeout
    };

    appendAdditonalAttribites(options, additionalAttributes);
    
    return options;
}

module.exports.requestUserToken = function (appToken, serviceCredentials, additionalAttributes, scopes, subdomain, zoneId, cb) {
    //make it backward-compatible (where zoneId is not provided at all)
    if (typeof zoneId === 'function') {
        cb = zoneId;
        zoneId = null;
    }

    var error = validateParameters(serviceCredentials, cb);
    if(error) {
        return cb(error, null);
    }

    var urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    // jwt bearer flow
    var options = buildOptions(serviceCredentials, 
                                additionalAttributes, 
                                urlWithCorrectSubdomain, 
                                'urn:ietf:params:oauth:grant-type:jwt-bearer', 
                                zoneId,
                                10*1000);

    //add Assertion
    options.form.assertion = appToken;

    if (scopes !== null) {
        options.form.scope = scopes;
    }

    return _requestToXSUAA("requestUserToken", options, false, cb);
}

module.exports.requestClientCredentialsToken = function (subdomain, serviceCredentials, additionalAttributes, zoneId, cb) {
    //make it backward-compatible (where zoneId is not provided at all)
    if (typeof zoneId === 'function') {
        cb = zoneId;
        zoneId = null;
    }

    // input validation
    var error = validateParameters(serviceCredentials, cb);
    if(error) {
        return cb(error, null);
    }

    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    var options = buildOptions(serviceCredentials, 
        additionalAttributes, 
        urlWithCorrectSubdomain, 
        'client_credentials', 
        zoneId,
        2*1000);

    appendAdditonalAttribites(options, additionalAttributes);

    return _requestToXSUAA("requestClientCredentialsToken", options, false, cb);
};

module.exports.fetchKeyFromXSUAA = function (tokenKeyUrl, zid, cb) {
    // try to obtain key from UAA
    var options = {
        url: tokenKeyUrl,
        timeout: 2000,
        headers: {
            "User-Agent": constants.USER_AGENT,
        },
        followRedirect: false,
        maxAttempts: 3,
        retryDelay: 500,
        retryStrategy: requestRetry.RetryStrategies.HTTPOrNetworkError
    };    

    requestRetry.get(options, function (err, response, body) {
        if (err) {
            return cb(err);
        }

        if (response.statusCode !== 200) {
            var error = new Error('Call was not successful. Error Code: ' + response.statusCode + " " + body);
            error.statuscode = response.statusCode;
            error.body = body;
            return cb(error);
        }

        try {
            var json = JSON.parse(body);
            return cb(null, json);
        } catch (e) {
            var error = new Error('Error parsing response from UAA: ' + e)
            return cb(error);
        }
    });
}